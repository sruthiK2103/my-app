#Bootstrap Install
Install bootstrap using npm install --save bootstrap@3
In angular.json file update styles with bootstrap path in node modules. 
Check whether bootstrap has installed properly or not by inspecting html page style tags after you run the app.

#use ng serve --port 4000 to change port number, default port is 4200.

#How an angular app gets loaded and started

main.ts file contains bootstrapModule as AppModule (this tells angular to load that component
at the time of bootstrap) & import AppModule.
In AppModule.ts file bootstrap array we add AppComponent.
index.html file is the only file served by the server. It contains Js script imports which 
will be loaded first and executed at runtime.
index.html contains <app-root> (which is a selector in app.component.ts). app.component.ts file
has html file which is loads its content in between <app-root> tag.

#components
Easy to exchange, used for re-use.
egs : navbar, main area, side bar.

Root component is app.component in which different selectors in the app will be added.

## Create new component

### manually
create components in app folder. 
Register new component in app.module.ts file declarations & import new component from its respective
path.
Add the new component selector in app.component.html file to use the new component.

### Through CLI
ng generate component [component Name] or ng g c [component Name]  command generates ts,css,html, spec file 
of the new component and adds the component in app.module.ts automatically.

template (in-line html code) or templateUrl should be present for a component. Use styles tag array
to add in-line styles.

### selectors in components
selectors should be unique and can be different types like element, attribute or class.
eg: selector:'app-server' or '[app-server]' or '.app-server'

### constructor
Its is called at the time of component creation by angular.

### Nest components
nest components by adding their selectors in different components

#modules
used to bundle different components into packages.
@NgModule in app.module.ts file has declarations in which we mention components, imports in which 
we mention different module needed to import. 

#Data Binding = communication
 
## Typescript code (Business Logic)   --->(output data)  Template(HTML)    use 

 string interpolation (  {{data}} ) - should return a string as the result (a num will be converted to string )
 property Binding ( [property]="data" )

### property Binding vs string interpolation
 To output/print data use string interpolation and to change a property use property Binding


 ##Typescript code (Business Logic)   <---(React to user events)  Template(HTML)    use 

 Event Binding ( (event)="expression" )

 ##combination of both: two-way-Binding ( [(ngModel)]="data" )
 For Two-Way-Binding to work, you need to enable the ngModel  directive. 
 This is done by adding the FormsModule  to the imports[]  array in the AppModule.
 You then also need to add the import from @angular/forms  in the app.module.ts file:
 import { FormsModule } from '@angular/forms'; 

 #Directives
 Instructions to the DOM. components are Directives with a template.
 ##Structural Directives : changes the DOM. Starts with a *
 
*ngIf element will be added only when the condition is true.
 eg: *ngIf=""
ng-template is a component/directive which can be used to mark templates in the DOM. Used with else

*ngFor is used to loop through array of elements

*ngFor = "let anyName of NamefromTypescriptFile; let i=index"  -- index starts from 0

## attribute Directives
Unlike Structural Directives, these dont add or remove elements. They only change the element
they were plced on.

ngStyle is used to dynamically add styles.
ngClass is used to add css class only when certain condition is true.

eg: [ngStyle]="{'background-color': 'red'}" or [ngStyle]="{backgroundColor: 'red'}" or
[ngStyle]="{backgroundColor: getColor()}" 
[ngStyle]="{backgroundColor:even %2 !== 0? 'yellow': 'blue'}"
[ngClass]="{className : condition}"  --Note: className with hypens should be used in ''
eg: [ngClass]="{odd:odd %2 !== 0}"
Both these work with property binding which takes javascript object.

##Creating a Model class

use model class in components eg to use model as an array: x:modelClassName [] = [
  new Recipe(pass arugments as in the model class constructor);
  new Recipe('', '', '')
]; 
import model class into component

## Debugging
#Debugging code in browser using sourcemaps

Js files (eg: main.bundle.js)supports sourcemaps. sourcemaps allows browser to translate/map JS 
to typescript files. 
In chrome developer tools:
1.put a break point in main.bundle.jS file that takes you to respective ts file.
2. Instead we can directly access our app ts files in webpack folder: webpack/./src/app/....

#Using Augury to Dive into Angular Apps
Augury - chrome extension - nice little tool to analayze the angular application & dependencies.

### Property and Event binding
Can be used on Html elements - native properties & events, Directives & components - custom properties & events

By default all properties of elements are accessible inside of their own components, not from outside.
we have to be explicit on which properties you want to expoose to the outside world.

#custom property binding

@Input() - is used to make a property bindable from outside

If you have a property in child comp, to use it in parent we have to add @Input() to the property in the child 
comp.ts file and import from @angular/core.

Eg: child comp @Input() x:string      parent comp y="test"
In parent comp html file,  [x]="y"

#Assigning an alias to custom properties

pass the name you want the property to have outside in the @Input arguments.

Eg: child comp @Input('abc') x:string      parent comp y="test"
In parent comp html file,  [abc]="y"

#Binding to custom events

@Output() - is used to make an event listnable from outside - because we are passing our own event out of the component.

EventEmitter is an object in angular which allows to emit your own events.
emit() is used to emit the event.

If you have a custom event in child comp, to use it in parent we have to add @Output() to the property in the child 
comp.ts file and import both Output and EventEmitter from @angular/core. 

Eg: @Output() serverCreated = new EventEmitter<{serverName:string, serverContent:string}>();
 
onAddServer() {
this.serverCreated.emit({
      serverName:this.newServerName, 
      serverContent:this.newServerContent
    }); }

In app.comp.html <childComp (serverCreated)="onServerAdded($event)"></childComp>

#Assigning an alias to custom events

pass the name you want the eventto have outside in the @Output arguments.

Eg: @Output('Screated') serverCreated = new EventEmitter<{serverName:string, serverContent:string}>();
In app.comp.html <childComp (Screated)="onServerAdded($event)"></childComp>

###View Encapsulation

Style encapsulation is a behaviour enforced by angular, which is not a default behaviour of the browser. 
The CSS styles defined in a comp will belong to just tht comp.

Angular adds attributes to all elements and apply styles to the element with that attribute. 
* Each comp will have diff unique attribute for all the elements.

Angular emulates the shadow DOM (its a technology not supported by all browsers where each element has its own shadow dom behind it
where then it could assign styles to each element).
Its default behaviour of view encapsulation in angular.

Angular encapsulates our styles. We can override the encapsulation by adding encapsulation to @Component in ts file
import ViewEncapsulation from @angular/core in ts file

encapsulation: ViewEncapsulation.(Native/None/Emulated)

Emulated is the default

None: we dont see the attributes being added to the elements in tht comp (* other comps will still have attributes)
* Styles defined in tht comp will be applied globally (throughout the app)

Native: uses the shadow DOM. Same as emulated but only in browsers which support it.


### Using local references in templates

To get the input value just at that point of time, we can use local reference (#) instead of two way data binding

local reference can be placed on any html element and any where in the templates (but not in typescript code).
This local reference will hold the reference to the whole html element with all its properties not the value.

local references is used to get access to some elements in our template and then use it directly in the template or use the value in typescript

Eg: in html file, <input type="text" class="form-control" #serverNameInput>  serverNameInput returns this input html element.
In html : onAddBlueprint(serverNameInput)
we can use it in html file directly : serverNameInput.value 
or in typescript onAddBlueprint(nameInput: HTMLInputElement) {
    this.bluprintCreated.emit({
      serverName:nameInput.value }); }

### Getting access to the template and DOM with @ViewChild 

With local references we get the reference when we call that method but sometimes we want to get the access before we call that method.
with @ViewChild we can fetch local references and get direct access to elements in our template.

We can get access to the element directly from typescript code using @ViewChild. 

Eg: In html file,  <input type="text" class="form-control" #serverContentInput>

In ts file, @ViewChild('serverContentInput') serverContentInput: ElementRef;  import viewChild, ElementRef from @angular/core.
viewChild is of type ElementRef, which is reference to tht element.
ElementRef has a property called nativeElement which gives access to the underlying element.

@ViewChild won't work without an argument. The argument is like a selector on how we want to select tht element
-can pass as a string name of a local ref 
-pass comp type(if we are using it in app comp, we can use @ViewChild(childComponent) to get access to first occurence of the child comp in app comp

in typescript onAddBlueprint(nameInput: HTMLInputElement) {
    this.bluprintCreated.emit({
      serverName:nameInput.value 
      serverContent: this.serverContentInput.nativeElement.value;

}); }

** we should not change the dom from typescript.


### Projecting content into components with ng-content

code in between opening n closing tag of ur own comp will be lost and will not be taken care by angular by default.
To avoid this, add <ng-content></ng-content> in our comp where we want tht code to be displayed.

ng-content is a directive that projects code in between opening n closing tag of ur own comp into the comp where it is placed.

Nice feature to build reusable widgets like a tab widget where each tab has content cmng from other source and which we dont want to 
pass always through property binding.

For complex property binding logic we can use ng-content instead.

### understanding the component life cycle

If a new comp is created by angular

1. ngOnChanges - executed multipe times
called first when the comp is created and called after a bound input property changes (i.e. whenever properties with @Input recieves new values)	
2. ngOnInit - called once the comp is initialized (ie once the obj is created)- will run after the constructor
3. ngDoCheck - called during every change detection run (checks on every change eg: property change, click, timer fires)
4. ngAfterContentInit - called after content(ng-content) has been projected into view
5. ngAfterContentChecked - called everytime the projected content has been checked
6. ngAfterViewInit - called after comp's view (and child views) has been initalized
7. ngAfterViewChecked - called everytime the view (and child views) has been checked
8. ngOnDestroy - called once the comp is about to be destroyed (eg: if *ngIf is false, removes the ele from DOM. ngOnDestroy is called before destroying)


##seeing life cycle hooks in action

implementing the life cycle hook interfaces is a good practice. Import all the life cycle hook interfaces from @angular/core
* constructor is called first before ngOnInit 
* ngOnChanges is called first before ngOnInit -
the only hook tht recieves an argument 'changes' of type SimpleChanges (need to import from @angular/core)

-----come back to 73-76 lectures-----
#### Directives Deep Dive

Attribute Directives
Look like a normal html attribute (possibly with data binding or event binding)
only affect/change the element they are added to.
ngClass ngStyle

vs

Structural Directives
Look like a normal html attribute but having a leading * (for desugaring)
Affect a whole area in the DOM (elements get added/removed)
** we can't have more than one structural directive on an element. Using it will throw an error.
*ngIf *ngFor

##Creating a basic directive

we can create a shared folder to create all directives

Through angular-cli

ng g d better-highlight or ng generate directive better-highlight

Manually creation
Create a folder in app folder for directive and create a file called [xyz].directive.ts

Eg:

import {Directive,ElementRef,OnInit} from '@angular/core';

@Directive({  //to configure the directive we need this obj, one of it is selector
selector:'appBasicHighlight' - element or '[appBasicHighlight]'  - attribute
})
export class BasicHighlightDirective implements OnInit{
  //we can inject the element the directive sits on into this directive, can be done through constructor
  constructor(private elementRef:ElementRef) {
    }
  ngOnInit(){
    this.elementRef.nativeElement.style.backgroundColor = 'green';
    //but this is not good practice to directly access the element
  }
}

* to use this directive we need to inform angular about the directive
in app.module.ts file declarations, add directive and import it.

To use directive
<p appBasicHighlight>style me</p>  //as the selector is attr, just use it as attr

//directives doesn't have all life cycle hooks as components (view related hooks are not there).
onInit and onDestroy are few that can be used on directives.

##using a renderer to build a better directive
we can use a renderer to get the element, its the better way to access DOM

Angular is not limited to running in the browser, service workers are the enivorments where 
we might not have DOM access. we might get an error in some circumstances if we directly access the DOM.

so its a better practice to use the renderer and its methods to access DOM.
* renderer type has changed from Rendererv2 to Renderer2 and few methods has been changed.

eg: In directive file
  constructor(private elRef:ElementRef, private renderer:Renderer2) { }
  ngOnInit() {
    this.renderer.setStyle(this.elRef.nativeElement,'background-color', 'blue');
  }

Renderer methods: https://angular.io/api/core/Renderer2

##using host listeners to listen to host events

if we need to react to any events on the element directive sits on, 
use the decorator @HostListener and it to the method we want to execute (eg: mouseover, mouseleave).
 this can be triggered when some event occurs, which can passed as a string argument to @HostListener

 @HostListener takes the events supported by DOM element the directive sits on as the argument
we can also recieve event data (eventData), we can also listen to custom events and get that data 
eg: 
@HostListener('mouseenter') mouseover(eventData:Event) {
    this.renderer.setStyle(this.elRef.nativeElement,'background-color', 'blue');
  }
##using HostBinding to bind to Host properties

other way to access the dom elements is through HostBinding. we can use either a renderer or this.
we can bind to any element the directive is sitting on.
First we need to bind @HostBinding to a property (eg: backgroundColor)
@HostBinding takes a string argument which is property of the hosting element we want to bind
eg:
@HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';
@HostListener('mouseenter') mouseover(eventData:Event) {
    this.backgroundColor = 'blue';
  }

##Binding to directive properties
we would be able to set the properties/values in the directive dynamically instead of hard coding in the
directive.
 we can improve that by using custom property binding (as a side note custom event binding can also be used on directives)
 @Input() defaultColor: string = 'transparent';
 @Input() highligthColor: string = 'blue';

 we can bind these from outside.
 <p appBetterHighlight [defaultColor]="'yellow'" [highlightColor]="'red'">style me</p>

we can put directive name in [], if we have an alias for a property as same name as directive name.
eg: @Input('appBetterHighlight') highligthColor: string = 'blue';

<p [appBetterHighlight]="'red'" [defaultColor]="'yellow'">style me</p>

\\General thing about property binding
if we are passing down a string, we can omit [] and ''.
eg: [defaultColor]="'yellow'" can be written as defaultColor="yellow"

##what happens behind the scenes on structural directives

* is used to indicate that it is a structural directive. Behind the scenes angular transforms
them into something else
<div *ngIf="!onlyOdd">...</div> behind the scenes * is transformed to 
<ng-template [ngIf]="onlyOdd">...</ng-template> 

##Building a structural directive
create a directive using cli n g d unless - opp of ngIf
Get the condition as in Input

